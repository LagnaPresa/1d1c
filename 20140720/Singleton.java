package net.n39i.ltx1d1c.d140720;

// Java の Enum が好きです。

// 良い点
// 1. クラスベース
// Java の Enum は他言語に見られるような「名前付き整数」ではありません。
// フィールドもメソッドも定義できます。そして型安全です。
// プログラマがドメインの詳細を心得ていなかったとしても、 Fruit 型の変数に Vegetable.WATERMELON を代入することはできません。

// 2. シリアライズが安全
// Enum は独自のシリアライズ機構を持っていて、自前のオブジェクトをシリアライズするよりはずっと安全です。
// 例えば Singleton(GoF) でクラスを実装しようとする際、オブジェクトの唯一性を守るためにコンストラクタに気を払うでしょう。
// しかしコンストラクタ以外のオブジェクト生成を対策するのは少々知識と手間が要ります。（ Object#readObject の実装とか)
// Enum の列挙定数としてオブジェクトを作れば、その辺りは自前で実装する必要はなくなります。
// ただ Enum 型（全ての Enum のスーパタイプ）が強制的に Serializable を実装してしまっているのはちょっとやりすぎだと思います。

// 不満な点
// 1. モックオブジェクトが作りにくい
// その型のインスタンスが予め全て決まってしまうので、列挙定数以外のインスタンスを用意できなくなります。
// プロダクトコード中ではむしろそれが目的だったりしますが、テストコードではこれが厄介になることがあります。
// Interface を実装できるので、 Enum を直接指定しないでコードを書くという手もありますが、
// それだとそもそも Enum の目的である、予め定義したインスタンス以外が生成されないことを前提としたコードではなくなるという、
// 自己矛盾が発生したりします。ちょっと列挙っぽいドメインであっても、テストする際どうなるか考えて Enum かどうか
// 決めるといいかもしれません。

// 2. スーパータイプが作れない
// Enum を幾つか似た目的に作っていると、共通処理をスーパタイプに書きたくなることがあります。（ファウラーのレイヤスーパタイプ）
// しかし Enum はスーパタイプを継承することができません。
public enum Singleton {

	INSTANCE;

	private String someProperties = "";

	@Override
	public String toString() {
		return name() + ":" + someProperties;
	}

}

//あと以前ちょっとハマったのが、エンクロージングインスタンスにアクセスできない（持てない？）というところです。
//要するに暗黙的に static になります。
